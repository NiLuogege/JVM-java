# 基本流程 
- 字节码文件 通过classLoader 解析为 ClassFile
- ClassFile 再被转换为 Class 对象

# com.niluogege.javajvm.HelloWorld 方法执行指令层面分析
### 方法如下
```
    public static void main(String[] args) {
        int sum = 1;
        for (int i = 2; i <= 3; i++) {
            sum += i;
        }
        System.out.println(sum);
    }
```

### 指令执行顺序如下
##### 操作码字节流（16进制） 43c053d1c06a3000d1b1c603c840201a7fff4b200021bb60003b1
1. pc寄存器值 ：0x4 对应的指令 ICONST_1 => 当前Frame的局部变量表：[{"num":0},{"num":0},{"num":0}] 当前Frame的操作数栈：[{"num":1},{"num":0}]
2. pc寄存器值 ：0x3c 对应的指令 ISTORE_1 => 当前Frame的局部变量表：[{"num":0},{"num":1},{"num":0}] 当前Frame的操作数栈：[{"num":1},{"num":0}]
3. pc寄存器值 ：0x5 对应的指令 ICONST_2 => 当前Frame的局部变量表：[{"num":0},{"num":1},{"num":0}] 当前Frame的操作数栈：[{"num":2},{"num":0}]
4. pc寄存器值 ：0x3d 对应的指令 ISTORE_2 => 当前Frame的局部变量表：[{"num":0},{"num":1},{"num":2}] 当前Frame的操作数栈：[{"num":2},{"num":0}]
5. pc寄存器值 ：0x1c 对应的指令 ILOAD_2 => 当前Frame的局部变量表：[{"num":0},{"num":1},{"num":2}] 当前Frame的操作数栈：[{"num":2},{"num":0}]
6. pc寄存器值 ：0x6 对应的指令 ICONST_3 => 当前Frame的局部变量表：[{"num":0},{"num":1},{"num":2}] 当前Frame的操作数栈：[{"num":2},{"num":3}]
7. pc寄存器值 ：0xa3 对应的指令 IF_ICMPGT => 当前Frame的局部变量表：[{"num":0},{"num":1},{"num":2}] 当前Frame的操作数栈：[{"num":2},{"num":3}]
8. pc寄存器值 ：0x1b 对应的指令 ILOAD_1 => 当前Frame的局部变量表：[{"num":0},{"num":1},{"num":2}] 当前Frame的操作数栈：[{"num":1},{"num":3}]
9. pc寄存器值 ：0x1c 对应的指令 ILOAD_2 => 当前Frame的局部变量表：[{"num":0},{"num":1},{"num":2}] 当前Frame的操作数栈：[{"num":1},{"num":2}]
10. pc寄存器值 ：0x60 对应的指令 IADD => 当前Frame的局部变量表：[{"num":0},{"num":1},{"num":2}] 当前Frame的操作数栈：[{"num":3},{"num":2}]
11. pc寄存器值 ：0x3c 对应的指令 ISTORE_1 => 当前Frame的局部变量表：[{"num":0},{"num":3},{"num":2}] 当前Frame的操作数栈：[{"num":3},{"num":2}]
12. pc寄存器值 ：0x84 对应的指令 IINC => 当前Frame的局部变量表：[{"num":0},{"num":3},{"num":3}] 当前Frame的操作数栈：[{"num":3},{"num":2}]
13. pc寄存器值 ：0xa7 对应的指令 GOTO => 当前Frame的局部变量表：[{"num":0},{"num":3},{"num":3}] 当前Frame的操作数栈：[{"num":3},{"num":2}]
14. pc寄存器值 ：0x1c 对应的指令 ILOAD_2 => 当前Frame的局部变量表：[{"num":0},{"num":3},{"num":3}] 当前Frame的操作数栈：[{"num":3},{"num":2}]
15. pc寄存器值 ：0x6 对应的指令 ICONST_3 => 当前Frame的局部变量表：[{"num":0},{"num":3},{"num":3}] 当前Frame的操作数栈：[{"num":3},{"num":3}]
16. pc寄存器值 ：0xa3 对应的指令 IF_ICMPGT => 当前Frame的局部变量表：[{"num":0},{"num":3},{"num":3}] 当前Frame的操作数栈：[{"num":3},{"num":3}]
17. pc寄存器值 ：0x1b 对应的指令 ILOAD_1 => 当前Frame的局部变量表：[{"num":0},{"num":3},{"num":3}] 当前Frame的操作数栈：[{"num":3},{"num":3}]
18. pc寄存器值 ：0x1c 对应的指令 ILOAD_2 => 当前Frame的局部变量表：[{"num":0},{"num":3},{"num":3}] 当前Frame的操作数栈：[{"num":3},{"num":3}]
19. pc寄存器值 ：0x60 对应的指令 IADD => 当前Frame的局部变量表：[{"num":0},{"num":3},{"num":3}] 当前Frame的操作数栈：[{"num":6},{"num":3}]
20. pc寄存器值 ：0x3c 对应的指令 ISTORE_1 => 当前Frame的局部变量表：[{"num":0},{"num":6},{"num":3}] 当前Frame的操作数栈：[{"num":6},{"num":3}]
21. pc寄存器值 ：0x84 对应的指令 IINC => 当前Frame的局部变量表：[{"num":0},{"num":6},{"num":4}] 当前Frame的操作数栈：[{"num":6},{"num":3}]
22. pc寄存器值 ：0xa7 对应的指令 GOTO => 当前Frame的局部变量表：[{"num":0},{"num":6},{"num":4}] 当前Frame的操作数栈：[{"num":6},{"num":3}]
23. pc寄存器值 ：0x1c 对应的指令 ILOAD_2 => 当前Frame的局部变量表：[{"num":0},{"num":6},{"num":4}] 当前Frame的操作数栈：[{"num":4},{"num":3}]
24. pc寄存器值 ：0x6 对应的指令 ICONST_3 => 当前Frame的局部变量表：[{"num":0},{"num":6},{"num":4}] 当前Frame的操作数栈：[{"num":4},{"num":3}]
25. pc寄存器值 ：0xa3 对应的指令 IF_ICMPGT => 当前Frame的局部变量表：[{"num":0},{"num":6},{"num":4}] 当前Frame的操作数栈：[{"num":4},{"num":3}]
26. pc寄存器值 ：0xb2 对应的指令 GET_STATIC => 当前Frame的局部变量表：[{"num":0},{"num":6},{"num":4}] 当前Frame的操作数栈：[{"num":4},{"num":3}]
27. pc寄存器值 ：0x1b 对应的指令 ILOAD_1 => 当前Frame的局部变量表：[{"num":0},{"num":6},{"num":4}] 当前Frame的操作数栈：[{"num":4},{"num":6}]
28. pc寄存器值 ：0xb6 对应的指令 INVOKE_VIRTUAL => 当前Frame的局部变量表：[{"num":0},{"num":6},{"num":4}] 当前Frame的操作数栈：[{"num":4},{"num":6}]

##### 每一步解析
1. 初始化一个1 放到到操作数栈
2. 这个1 暂时没用 先出栈到 局部变量表2号位置上
3. 初始化一个2 放到到操作数栈
4. 这个2  暂时没有 先出栈到 局部变量表3号位置上
5. 把局部变量表3号位置上 的2 入栈到操作数栈中
6. 把3入栈到操作数栈中
7. 3和2 进行对比，发现 2 《=3 成立，程序继续
8. 把局部变量表2号位置上的1  入栈到操作数栈中
9. 把局部变量表3号位置上的2  入栈到操作数栈中
10. 操作数栈顶两个数相加（1 和 2）等于3， 并在压入操作数栈顶
11. 将这个3 暂时没用 先出栈到 局部变量表2号位置上
12. 局部变量表3号位置上的 2 进行+1 操作，变成3
13. 无条件跳转
14. 把局部变量表3号位置上的3  入栈到操作数栈中
15. 把3入栈到操作数栈中
16. 3和3 进行对比，发现 3 《=3 成立，程序继续
17. 把局部变量表2号位置上的3  入栈到操作数栈中
18. 把局部变量表3号位置上的3  入栈到操作数栈中
19. 操作数栈顶两个数相加（3 和 3 ） 等于6,并在压入操作数栈顶
20. 将这个6 暂时没用 先出栈到 局部变量表2号位置上
21. 局部变量表3号位置上的 3 进行+1 操作，变成4
22. 无条件跳转
23. 把局部变量表3号位置上的4  入栈到操作数栈中
24. 把3入栈到操作数栈中
25. 3和4 进行对比，发现 3 《=4 不成立，不继续进行玄幻
26. 获取指定类的静态字段，并将其压入栈顶
27. 把局部变量表2号位置上的6  入栈到操作数栈中
28. 调用 实例方法（System.out.println()）进行输出